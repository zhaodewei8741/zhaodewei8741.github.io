<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对象的创建与继承</title>
      <link href="2021/01/10/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>2021/01/10/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = createCar(<span class="string">&#x27;wind&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car1);</span><br><span class="line"><span class="built_in">console</span>.log(car1.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>缺点：对象无法识别，所有实例都指向一个原型 <code>Object.prototype</code></p><h3 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">&#x27;wind&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car1);</span><br><span class="line"><span class="built_in">console</span>.log(car1.__proto__ == Car.prototype);</span><br></pre></td></tr></table></figure><p>优点：实例可以被识别为一个特定的类型</p><p>缺点：每次创建实例时，每个方法都要被创建一次。可以将方法单独封装在构造函数外部</p><h3 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">Car.prototype.name = <span class="string">&#x27;wind&#x27;</span>;</span><br><span class="line">Car.prototype.getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.wind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure><p>优点：方法不会被重新创建</p><p>缺点：所有属性和方法都会共享；不能初始化参数</p><h4 id="原型模式优化"><a href="#原型模式优化" class="headerlink" title="原型模式优化"></a>原型模式优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Car</span>,</span><br><span class="line">  <span class="title">name</span>: &#x27;<span class="title">wind</span>&#x27;,</span><br><span class="line">  <span class="title">getName</span>: (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car()</span><br></pre></td></tr></table></figure><p>提高了封装性，但没有改变其原有缺点</p><h3 id="4-、组合模式"><a href="#4-、组合模式" class="headerlink" title="4 、组合模式"></a>4 、组合模式</h3><p>构造函数+原型模式组合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Car</span>,</span><br><span class="line">    <span class="title">getName</span>: (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：属性可以分为共享属性和私有属性，使用最广泛的方式</p><p>缺点：封装性</p><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        Car.prototype = &#123;</span><br><span class="line">            <span class="title">constructor</span>: <span class="title">Car</span>,</span><br><span class="line">            <span class="title">getName</span>: (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">&#x27;wind&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> car2 = <span class="keyword">new</span> Car(<span class="string">&#x27;fire&#x27;</span>);</span><br><span class="line"><span class="comment">// 报错 getName is not a function</span></span><br><span class="line">car1.getName();</span><br><span class="line"><span class="comment">// 注释掉上一句，可以正常执行 输出wind</span></span><br><span class="line">car2.getName();</span><br></pre></td></tr></table></figure><p>使用此类动态原型模式时，不能用对象字面量重写原型</p><p>报错原因：</p><p>回顾 new 的实现步骤：</p><ol><li>首先新建一个对象</li><li>然后将对象的原型指向 Car.prototype</li><li>然后 Car.apply(obj)</li><li>返回这个对象</li></ol><p>回顾 apply 的实现步骤，会执行 obj.Car方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！</p><p>解决： 在if语句的最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Car(name)</span><br></pre></td></tr></table></figure><h3 id="5、寄生构造函数模式"><a href="#5、寄生构造函数模式" class="headerlink" title="5、寄生构造函数模式"></a>5、寄生构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.getName = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">&#x27;wind&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(car <span class="keyword">instanceof</span> Car); </span><br><span class="line"><span class="built_in">console</span>.log(car <span class="keyword">instanceof</span> <span class="built_in">Object</span>); </span><br></pre></td></tr></table></figure><p>与工厂模式类似，只是在创建对象时多使用了一个new，创建的实例与构造函数没有关系。</p><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象，指没有公共属性，其方法也不引用this的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">car</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.sayName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = car(<span class="string">&#x27;wind&#x27;</span>)</span><br><span class="line">car.sayName(); <span class="comment">// wind</span></span><br><span class="line">car.name = <span class="string">&#x27;fire&#x27;</span></span><br><span class="line">car.sayName(); <span class="comment">// wind</span></span><br><span class="line"><span class="built_in">console</span>.log(car.name); <span class="comment">// fire</span></span><br></pre></td></tr></table></figure><p>与寄生构造函数模式的区别</p><p>1、新创建的实例方法不引用this</p><p>2、不使用new操作符调用构造函数</p><h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;wind&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()); <span class="comment">// wind </span></span><br></pre></td></tr></table></figure><p>缺点：</p><p>1、引用类型的属性被所有实例共享，一变全变</p><p>2、在创建Child的实例时，不能向Parent传参</p><h3 id="2、借用构造函数（经典继承、对象冒充继承）"><a href="#2、借用构造函数（经典继承、对象冒充继承）" class="headerlink" title="2、借用构造函数（经典继承、对象冒充继承）"></a>2、借用构造函数（经典继承、对象冒充继承）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.names = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;daisy&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure><p>优点：</p><p>1、避免引用类型的属性被所有实例共享</p><p>2、可以在Child中向Parent只能给传参</p><p>缺点：</p><p>方法都在构造函数中定义，每次创建实例都会创建一遍方法</p><h3 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h3><p>原型链+经典继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure><p>融合原型链继承和构造函数的优点，是最常用的继承模式</p><h3 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 <code>Object.create()</code> 的模拟实现，将传入的对象作为创建的对象的原型。</p><p>缺点：</p><p>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</p><h3 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;wind&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个仅仅用于封装继承过程的函数，最后返回对象</p><p>缺点：同经典继承一样，重复创建实例方法</p><h3 id="6、寄生组合式继承"><a href="#6、寄生组合式继承" class="headerlink" title="6、寄生组合式继承"></a>6、寄生组合式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 二次调用父级构造函数</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次调用父级构造函数</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>缺点：</p><p>会调用两次父级构造函数</p><h4 id="避免重复调用"><a href="#避免重复调用" class="headerlink" title="避免重复调用"></a>避免重复调用</h4><p>不使用<code>Child.prototype=new Parent()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br></pre></td></tr></table></figure><h4 id="封装继承方法"><a href="#封装继承方法" class="headerlink" title="封装继承方法"></a>封装继承方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(parent.prototype);</span><br><span class="line">    prototype.constructor = child;</span><br><span class="line">    child.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是：</p><p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传输层协议</title>
      <link href="2021/01/10/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/01/10/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><ul><li>TCP是面向连接的、可靠的、基于字节流的传输层协议</li><li>UDP是一个面向无连接的传输层协议</li></ul><h4 id="详细区别"><a href="#详细区别" class="headerlink" title="详细区别"></a>详细区别</h4><p>1、tcp是基于连接的，可靠性高；udp是基于无连接的，可靠性较低；</p><p>2、由于tcp是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差；由于协议所致，安全性较高；而udp无连接，无建立连接的过程，因而实时性较强，安全略差；</p><p>3、在传输相同大小的数据时，tcp首部开销20字节；udp首部开销只有8个字节，tcp报头比udp复杂，故实际包含的用户数据较少。tcp无丢包，而udp有丢包，故tcp开销大，udp开销较小；</p><p>4、每条tcp连接只能是点到点的；udp支持一对一、一对多、多对一、多对多的交互通信。</p><h4 id="应用场景的区别"><a href="#应用场景的区别" class="headerlink" title="应用场景的区别"></a>应用场景的区别</h4><ul><li>由于TCP和UDP的特点，如果对实时性要求高和高速传输的场景下需要使用UDP；</li><li>如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；</li><li>在可靠性要求低追求效率的情况使用UDP；</li></ul><h2 id="TCP三大核心"><a href="#TCP三大核心" class="headerlink" title="TCP三大核心"></a>TCP三大核心</h2><ul><li><strong>面向连接</strong>：面向连接指的是客户端与服务端的连接，在双方互相通信之前，TCP需要三次握手建立连接。UDP则没有相应的建立连接的过程</li><li><strong>可靠性</strong>：TCP的可靠性只要体现在<strong>有状态</strong>和<strong>可控制</strong>,UDP不可靠的原因相同，<strong>无状态</strong>和<strong>不可靠</strong></li><li><strong>面向字节流</strong>：UDP数据传输基于数据报，仅仅是继承了IP层的特性，而TCP为了维护状态，将IP包变成了字节流</li></ul><blockquote><p><strong>有状态</strong>；TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错 </p><p><strong>可控制</strong>；意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发</p></blockquote><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>三次握手的目的是确认客户端、服务端的发送能力与接收能力</p><p>最开始双方都处于CLOSE状态，然后服务端开始监听某个端口，进入LISTEN状态，等待服务器连接</p><p><strong>第一次握手</strong>：客户端向服务端发送 连接报文请求， 进入SYN-SENT状态，其中TCP标志位里SYN = 1， ACK = 0， 选择一个初始的序号seq = x</p><p>客户端发送数据包，服务端收到了。</p><p>服务端可以确认客户端的发送能力，服务端的接收能力</p><p><strong>第二次握手</strong>   服务端收到请求报文，进入SYN-RCVD状态，向客户端发送 连接确认报文， SYN = 1， ACK = 1， 确认号为 x + 1,  同时也选择一个初始号 seq = y</p><p>服务端发送数据包，客户端收到了</p><p>客户端可以确认服务端的发送能力和接收能力</p><p>但服务端尚不能确认客户端的接受能力是否正常</p><p><strong>第三次握手</strong>   客户端收到服务端的连接确认报文之后，进入ESTABLISHED状态，再向服务器 发出确认， 确认号为 seq = y + 1, 序号为 seq = x + 1,  ACK 报文段可以携带数据，不携带数据则不消耗序号</p><p>客户端发送数据包，服务端收到了</p><p>服务端可以确认客户端的接收能力正常</p><p><strong><em>第三次握手是为了防止失效的连接请求到达服务器，让服务器打开错误连接</em></strong></p><p>服务端接收到客户端的确认后，进入ESTABLISHED状态，连接建立</p><img src="/img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89.png" class="三次握手" width="800" height="600" title="三次握手" alt="三次握手"><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><strong>第一次挥手</strong> 首先客户端主动关闭，向服务端发送FIN段，并进入<code>FIN_WAIT_1</code>状态。此阶段关闭客户端到服务端的数据传送，表明自己不再向被动方传送数据。此时客户端还可以接受数据。</p><p><strong>第二次挥手</strong> 服务端接收到FIN包后，通知应用进程并向客户端发送一个ACK，确认序号为收到序号+1，服务端进入<code>CLOSN_WAIT</code>状态，接收到ACK的客户端进入<code>FIN_WAIT_2</code>状态</p><p><strong>第三次挥手</strong> 服务端发送一个<code>FIN</code>包，并进入<code>LAST_ACK</code>状态。用来关闭服务端到客户端的数据传送，表明不再发送数据</p><p><strong>第四次挥手</strong> 客户端收到<code>FIN</code>包后， 发送一个ACK给服务端，确认序号为收到序号+1,并进入<code>TIME_WAIT</code>状态（2<code>MSL</code>），进入<code>CLOSED</code>状态</p><blockquote><p>注意了，这个时候，客户端需要等待两个 <code>MSL</code>(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 <code>ACK </code>成功到达，挥手结束，否则客户端重发 ACK。</p></blockquote><h4 id="为什么要等待2MSL"><a href="#为什么要等待2MSL" class="headerlink" title="为什么要等待2MSL"></a>为什么要等待2MSL</h4><ul><li>1 个 <code>MSL</code> 确保四次挥手中主动关闭方最后的 <code>ACK</code> 报文最终能达到对端</li><li>1 个 <code>MSL</code> 确保对端没有收到 <code>ACK</code> 重传的 FIN 报文可以到达</li></ul><h4 id="为什么是四次挥手而不是三次"><a href="#为什么是四次挥手而不是三次" class="headerlink" title="为什么是四次挥手而不是三次"></a>为什么是四次挥手而不是三次</h4><p>因为服务端在接收到<code>FIN</code>, 往往不会立即返回<code>FIN</code>, 必须等到服务端所有的报文都发送完毕了，才能发<code>FIN</code>。</p><p>因此先发一个ACK表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。 <code>如果是三次挥手会有什么问题？</code> 等于说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code>。</p><img src="/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89.png" class="四次挥手" width="800" height="600" title="四次挥手" alt="四次挥手"><h2 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h2><blockquote><p>半连接队列、全连接队列、SYN Flood攻击过程、如何应对这种攻击</p></blockquote><h4 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h4><p>当客户端发送<code>SYN</code>到服务端，服务端收到以后回复<code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时这个连接就被推入了<strong>SYN队列</strong>，也就是半连接队列。</p><h4 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h4><p>当客户端返回<code>ACK</code>, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</p><h4 id="SYN-Flood攻击原理"><a href="#SYN-Flood攻击原理" class="headerlink" title="SYN Flood攻击原理"></a>SYN Flood攻击原理</h4><p>SYN Flood 属于<strong>典型的 DoS/DDoS 攻击</strong>。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:</p><ul><li>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</li><li>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</li></ul><h4 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h4><p><strong>增加 SYN 连接</strong>，也就是增加半连接队列的容量。</p><p><strong>减少 SYN + ACK 重试次数</strong>，避免大量的超时重发。</p><p><strong>利用 SYN Cookie技术</strong>，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h2 id="TCP拥塞机制"><a href="#TCP拥塞机制" class="headerlink" title="TCP拥塞机制"></a>TCP拥塞机制</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="2021/01/09/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>2021/01/09/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)  <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><p>在这个例子中，定义了一个构造函数Person, 使用new创建了一个实例对象person</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个 <strong><em>函数</em></strong> 都有一个 <code>prototype</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Tom&#x27;</span> </span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// ES5中获取原型的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>函数的 <code>prototype</code> 指向一个对象，这个对象正是调用该构造函数而创建的实例对象的 <strong><em>原型</em></strong> 。也就是person的原型。</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>每一个对象(null除外)都具有一个属性 <code>__proto__</code> 指向对象的原型。</p><p><code>__proto__</code> 是 <strong><em>对象</em></strong> 独有属性, 这个属性是由浏览器实现的</p><p>原型可以理解为： 每一个对象（null除外）在创建的时候就会与之关联的另一个对象，每一个对象都会从原型继承属性。</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型的 <code>constructor</code> 指向关联的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person == Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class="原型链" width="800" height="600" title="原型链" alt="原型链"><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止，找到 <code>Object.prototype.__proto__</code> 为止，这就是原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>null表示“没有对象”，即该出不应该有值</p><p>所以 <code>Object.prototype.__proto__</code> 的值为 null 跟 <code>Object.prototype</code> 没有原型，其实表达了一个意思，这就是原型链的终点了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当获取 <code>person.constructor</code> 时，其实 person 中并没有 <code>constructor</code> 属性,当不能读取到 <code>constructor</code> 属性时，会从 person 的原型也就是 <code>Person.prototype</code> 中读取。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>引用《你不知道的JavaScript》中的话，就是：</p><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟DOM</title>
      <link href="2021/01/04/%E8%99%9A%E6%8B%9FDOM/"/>
      <url>2021/01/04/%E8%99%9A%E6%8B%9FDOM/</url>
      
        <content type="html"><![CDATA[<h3 id="真实DOM和其解析流程"><a href="#真实DOM和其解析流程" class="headerlink" title="真实DOM和其解析流程"></a>真实DOM和其解析流程</h3><h4 id="创建dom树"><a href="#创建dom树" class="headerlink" title="创建dom树"></a>创建dom树</h4><p>​    使用html分析器分析html分析，构建dom树（标记化和树构建）</p><h4 id="创建StyleRules"><a href="#创建StyleRules" class="headerlink" title="创建StyleRules"></a>创建StyleRules</h4><p>​    使用css分析器，分析css文件和元素上的inline样式，生成页面的样式表</p><h4 id="创建Render树"><a href="#创建Render树" class="headerlink" title="创建Render树"></a>创建Render树</h4><p>​    将dom树和样式表关联起来，构建一棵render树。每个dom节点都有attach方法，接受样式信息，返回一个render对象。这些render对象最终会构建成一棵render树。</p><h4 id="布局layout"><a href="#布局layout" class="headerlink" title="布局layout"></a>布局layout</h4><p>​    有了render树后，浏览器开始布局，为每个render树上的节点确定一个在显示屏上出现的精确坐标。</p><h4 id="绘制painting"><a href="#绘制painting" class="headerlink" title="绘制painting"></a>绘制painting</h4><p>​    render树和节点显示坐标确定之后，调用每个节点的paint方法，把它们绘制出来</p><p>​    构建dom树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上。会一边加载一边解析一边渲染。    </p><h3 id="JS操作真实DOM的代价"><a href="#JS操作真实DOM的代价" class="headerlink" title="JS操作真实DOM的代价"></a>JS操作真实DOM的代价</h3><p>​    原生JS或JQ操作dom时，浏览器会从构建dom树开始从头到尾执行一遍流程。</p><h3 id="虚拟DOM的好处"><a href="#虚拟DOM的好处" class="headerlink" title="虚拟DOM的好处"></a>虚拟DOM的好处</h3><p>​    web界面由dom树构建，当其中一部分发生变化时，其实就是对应某个dom节点发生了变化</p><p>​    虚拟dom是为了解决浏览器性能问题而被设计出来的。若一次操作中有10次更新dom的动作，虚拟dom不会立即操作dom，而将10次更新的diff内容保存到本地一个js对象中，最终将这个js对象一次性attch到dom树上，再进行后续操作，避免大量武威的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
